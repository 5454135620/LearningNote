 package java08面向对象多态;

class Fu
{
	int num=0;
	void fun1()
	{
		System.out.println("Fu fun_1");
	}
	void fun2()
	{
		System.out.println("Fu fun_1");
	}
	static void fun4()
	{
		System.out.println("Fu fun_4");
	}
	

}


class Zi extends Fu
{
	int num=1;
	void fun1()
	{
		System.out.println("Zi fun_1");
	}
	void fun3()
	{
		System.out.println("Zi fun_3");
	}
	static void fun4()
	{
		System.out.println("Zi fun_4");
	}

}

class Operator
{
	void fun(Fu f)
	{
		if(f instanceof Zi)//子类型有限时使用 -关键字
		{
			f.fun1();  
			f.fun2();
			//f.fun3();报错
			/* 
			 *   Fu f = new Zi();  //类型提升  向上转型  相对=右
			 *   //只能调用子类父类的共有方法 
			 *   //所以f.fun3();错误  
			 * */
			/*
			 * 多态方法调用子类对象特有属性：
			 * */
		    Zi z = (Zi)f;//类型强转 将父类的引用类型转化为子类类型   向下转型 
		    z.fun3();
			f.fun4();//类同
		}
		else if(f instanceof Fu)
		{
			f.fun1();  
			f.fun2();
			f.fun4();
		}
		
		/*
		 * 在多态中 成员变量 的特点：
		 * 无论编译和运行 都看引用类变量
		 * 非静态方法区  this.method()  动态绑定
		 * 
		 * 多态中 静态成员函数 的特点：
		 * 无论编译和运行 都看引用类变量：
		 * 静态方法区   Fu.method4()  静态绑定
		 * 
		 * */
	}
}

public class Java多态总结 {
	
	public static void main(String[] args)
	{
		
		/*
		Zi z = new Zi();
		z.fun1();//覆盖
		z.fun2();//继承
		z.fun3();//特有
		z.fun4();//静态方法覆盖  类名调用 之看前面
		
		
		
		Fu f = new Zi();//多态调用方式
	        //成员函数多态调用 运行看右边 编译左边
		//编译时：参阅引用型变量所属的类中是否有调用方法 如果有 编译通过 无编译失败；
		// 运行时：参阅对象所属的类中是否有调用的方法 ；
		// 出现f.fun3()问题
		  
		f.fun1(); //子类对象方法 多态覆盖  
		f.fun2();
		//f.fun3();
		f.fun4();//静态方法覆盖   类名调用 之看前面
		*/
		
		
		/*定义操作类  提高调用效率*/
		Operator A = new Operator();
		//A.fun(new Fu());
		A.fun(new Zi());
			
	}

}
